<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>YT Playlist Downloader</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background: #0f0f0f;
    color: #e1e1e1;
    min-height: 100vh;
    padding: 2rem 1rem;
  }

  .container { max-width: 900px; margin: 0 auto; }

  h1 { font-size: 1.6rem; font-weight: 600; margin-bottom: 1.5rem; color: #fff; }

  .input-group { display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1.25rem; }
  .row { display: flex; gap: 0.75rem; flex-wrap: wrap; align-items: center; }

  input[type="text"], input[type="number"] {
    padding: 0.6rem 0.85rem;
    border: 1px solid #333;
    border-radius: 6px;
    background: #1a1a1a;
    color: #e1e1e1;
    font-size: 0.95rem;
    outline: none;
    transition: border-color 0.2s;
  }
  input[type="text"] { flex: 1; min-width: 200px; }
  input[type="number"] { width: 80px; }
  input:focus { border-color: #5a9; }

  .path-row {
    display: flex; gap: 0.5rem; flex: 1; min-width: 200px; align-items: center;
  }
  .path-row input[type="text"] { min-width: 0; }

  .format-toggle {
    display: flex; border: 1px solid #333; border-radius: 6px;
    overflow: hidden; flex-shrink: 0;
  }
  .format-toggle label {
    padding: 0.6rem 1.1rem; cursor: pointer; font-size: 0.9rem;
    background: #1a1a1a; transition: background 0.2s, color 0.2s; user-select: none;
  }
  .format-toggle input { display: none; }
  .format-toggle input:checked + label { background: #5a9; color: #fff; }

  button {
    padding: 0.6rem 1.3rem; border: none; border-radius: 6px;
    font-size: 0.9rem; font-weight: 500; cursor: pointer;
    transition: background 0.2s, opacity 0.2s;
  }
  button:disabled { opacity: 0.4; cursor: not-allowed; }
  .btn-primary { background: #5a9; color: #fff; }
  .btn-primary:hover:not(:disabled) { background: #4b8a78; }
  .btn-danger { background: #c0392b; color: #fff; }
  .btn-danger:hover:not(:disabled) { background: #a93226; }
  .btn-warn { background: #d48b2a; color: #fff; }
  .btn-warn:hover:not(:disabled) { background: #b87720; }
  .btn-sm { padding: 0.35rem 0.8rem; font-size: 0.8rem; }
  .btn-ghost {
    background: transparent; color: #888; border: 1px solid #333;
  }
  .btn-ghost:hover:not(:disabled) { background: #222; color: #e1e1e1; }
  .btn-icon {
    background: none; border: none; padding: 0.2rem; cursor: pointer;
    color: #888; font-size: 1rem; line-height: 1; transition: color 0.15s;
    flex-shrink: 0;
  }
  .btn-icon:hover { color: #e1e1e1; }
  .btn-icon.retry { color: #d4a02a; }
  .btn-icon.retry:hover { color: #f0c040; }

  .message {
    padding: 0.7rem 1rem; border-radius: 6px; margin-bottom: 1rem; font-size: 0.9rem;
  }
  .message.error { background: #3a1515; border: 1px solid #6b2a2a; color: #f5a5a5; }
  .message.info { background: #152a3a; border: 1px solid #2a4a6b; color: #a5d5f5; }

  /* Playlist info panel */
  .playlist-info {
    background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 8px;
    padding: 1.25rem; margin-bottom: 1.25rem;
  }
  .playlist-info h2 { font-size: 1.15rem; margin-bottom: 0.25rem; color: #fff; }
  .playlist-info .meta { font-size: 0.85rem; color: #888; margin-bottom: 0.75rem; }

  /* Selection controls */
  .selection-controls {
    display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;
    margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #2a2a2a;
  }
  .selection-controls label { font-size: 0.85rem; color: #aaa; }
  .selection-count { font-size: 0.85rem; color: #5a9; margin-left: auto; }

  /* Selectable video list */
  .select-list { display: flex; flex-direction: column; gap: 0.35rem; max-height: 400px; overflow-y: auto; }
  .select-item {
    display: flex; align-items: center; gap: 0.6rem;
    padding: 0.45rem 0.6rem; border-radius: 5px;
    background: #151515; cursor: pointer; user-select: none;
    transition: background 0.15s;
  }
  .select-item:hover { background: #1e1e1e; }
  .select-item.deselected { opacity: 0.35; }
  .select-item input[type="checkbox"] {
    accent-color: #5a9; width: 16px; height: 16px; cursor: pointer; flex-shrink: 0;
  }
  .select-item .s-idx { font-size: 0.75rem; color: #555; width: 2.2rem; text-align: right; flex-shrink: 0; }
  .select-item .s-title {
    font-size: 0.85rem; color: #ccc; white-space: nowrap;
    overflow: hidden; text-overflow: ellipsis; flex: 1;
  }

  /* ===== Background downloads panel ===== */
  .downloads-panel {
    margin-top: 2rem; border-top: 1px solid #2a2a2a; padding-top: 1.25rem;
  }
  .downloads-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 0.75rem;
  }
  .downloads-header h2 { font-size: 1.1rem; color: #fff; }
  .downloads-actions { display: flex; gap: 0.5rem; }
  .downloads-panel .no-tasks { font-size: 0.85rem; color: #555; }

  .task-card {
    background: #1a1a1a; border: 1px solid #2a2a2a; border-radius: 8px;
    margin-bottom: 0.6rem; overflow: hidden;
  }
  .task-header {
    display: flex; align-items: center; gap: 0.75rem;
    padding: 0.75rem 1rem; cursor: pointer; user-select: none;
  }
  .task-header:hover { background: #1e1e1e; }
  .task-expand { font-size: 0.8rem; color: #555; transition: transform 0.2s; flex-shrink: 0; }
  .task-expand.open { transform: rotate(90deg); }
  .task-title { flex: 1; font-size: 0.9rem; color: #ddd; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .task-stats { font-size: 0.8rem; color: #888; flex-shrink: 0; }
  .task-badge {
    font-size: 0.7rem; padding: 0.15rem 0.5rem; border-radius: 10px;
    font-weight: 500; flex-shrink: 0;
  }
  .task-badge.downloading { background: #1a3a2a; color: #5a9; }
  .task-badge.starting { background: #2a2a1a; color: #aa5; }
  .task-badge.done { background: #1a2a3a; color: #5a9; }
  .task-badge.error { background: #3a1515; color: #f5a5a5; }
  .task-badge.cancelled { background: #2a2020; color: #c88; }
  .task-badge.paused { background: #2a2a1a; color: #d4a02a; }
  .task-btns { display: contents; }

  .task-progress-bar { height: 3px; background: #2a2a2a; margin: 0; }
  .task-progress-fill { height: 100%; background: #5a9; transition: width 0.4s; }

  .task-detail { padding: 0 1rem 0.75rem; display: none; }
  .task-detail.open { display: block; }
  .task-detail .video-list {
    display: flex; flex-direction: column; gap: 0.35rem; margin-top: 0.5rem;
    max-height: 350px; overflow-y: auto;
  }

  .video-item {
    background: #151515; border: 1px solid #222; border-radius: 5px;
    padding: 0.5rem 0.7rem;
  }
  .video-item .video-row {
    display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.3rem;
  }
  .video-item .video-title {
    font-size: 0.8rem; color: #aaa;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1;
  }
  .progress-bar-bg { height: 5px; background: #2a2a2a; border-radius: 3px; overflow: hidden; }
  .progress-bar-fill {
    height: 100%; background: #5a9; border-radius: 3px;
    transition: width 0.3s; width: 0%;
  }
  .progress-bar-fill.failed { background: #c0392b; width: 100%; }
  .video-item .status-label { font-size: 0.7rem; color: #666; margin-top: 0.2rem; }

  .hidden { display: none; }

  .spinner {
    display: inline-block; width: 14px; height: 14px;
    border: 2px solid #555; border-top-color: #5a9; border-radius: 50%;
    animation: spin 0.7s linear infinite; vertical-align: middle; margin-right: 0.4rem;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* ===== Directory browser modal ===== */
  .modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6);
    display: flex; align-items: center; justify-content: center;
    z-index: 100;
  }
  .modal-overlay.hidden { display: none; }
  .modal {
    background: #1a1a1a; border: 1px solid #333; border-radius: 10px;
    width: 480px; max-width: 95vw; height: 70vh;
    display: flex; flex-direction: column;
  }
  .modal-header {
    display: flex; align-items: center; gap: 0.75rem;
    padding: 1rem 1.25rem; border-bottom: 1px solid #2a2a2a;
    flex-shrink: 0;
  }
  .modal-header h3 { font-size: 1rem; color: #fff; flex: 1; }
  .modal-path {
    padding: 0.5rem 1.25rem; font-size: 0.8rem; color: #5a9;
    background: #151515; font-family: monospace;
    word-break: break-all; flex-shrink: 0;
  }
  .modal-body {
    flex: 1; overflow-y: auto; padding: 0.5rem 0; min-height: 0;
  }
  .dir-item {
    display: flex; align-items: center; gap: 0.6rem;
    padding: 0.5rem 1.25rem; cursor: pointer; font-size: 0.9rem;
    color: #ccc; transition: background 0.15s;
  }
  .dir-item:hover { background: #252525; }
  .dir-item .dir-icon { color: #5a9; flex-shrink: 0; }
  .dir-item.parent-dir { color: #888; }
  .modal-footer {
    display: flex; justify-content: flex-end; gap: 0.5rem;
    padding: 0.75rem 1.25rem; border-top: 1px solid #2a2a2a;
    flex-shrink: 0;
  }
  .modal-empty { padding: 1.5rem 1.25rem; font-size: 0.85rem; color: #555; text-align: center; }
  .modal-new-folder {
    display: flex; gap: 0.5rem; align-items: center;
    padding: 0.5rem 1.25rem; border-top: 1px solid #2a2a2a;
  }
  .modal-new-folder.hidden { display: none; }
  .modal-new-folder input[type="text"] {
    flex: 1; min-width: 0; font-size: 0.85rem; padding: 0.4rem 0.7rem;
  }
</style>
</head>
<body>
<div class="container">
  <h1>YT Playlist Downloader</h1>

  <!-- Input section -->
  <div class="input-group">
    <div class="row">
      <input type="text" id="urlInput" placeholder="Paste YouTube playlist URL..." autofocus>
      <button class="btn-primary" id="fetchBtn" onclick="fetchInfo()">Fetch Info</button>
    </div>
    <div class="row">
      <div class="path-row">
        <input type="text" id="pathInput" placeholder="Download path (default: ~/Downloads)" value="~/Downloads">
        <button class="btn-ghost btn-sm" onclick="openBrowser()" title="Browse...">Browse</button>
      </div>
      <div class="format-toggle">
        <input type="radio" name="fmt" id="fmtVideo" value="video" checked>
        <label for="fmtVideo">Video</label>
        <input type="radio" name="fmt" id="fmtAudio" value="audio">
        <label for="fmtAudio">Audio</label>
      </div>
    </div>
  </div>

  <div id="messageBox" class="message hidden"></div>

  <!-- Playlist info + selection panel -->
  <div id="playlistPanel" class="playlist-info hidden">
    <h2 id="plTitle"></h2>
    <div class="meta"><span id="plCount"></span> videos</div>

    <div class="selection-controls">
      <label>Range:</label>
      <input type="number" id="rangeFrom" min="1" value="1" onchange="applyRange()">
      <span style="color:#555">to</span>
      <input type="number" id="rangeTo" min="1" value="1" onchange="applyRange()">
      <button class="btn-ghost btn-sm" onclick="selectAll()">Select All</button>
      <button class="btn-ghost btn-sm" onclick="deselectAll()">Deselect All</button>
      <span class="selection-count" id="selCount">0 selected</span>
    </div>

    <div class="select-list" id="selectList"></div>

    <div style="margin-top:0.75rem">
      <button class="btn-primary" id="downloadBtn" onclick="startDownload()">Download Selected</button>
    </div>
  </div>

  <!-- Background downloads panel -->
  <div class="downloads-panel" id="downloadsPanel">
    <div class="downloads-header">
      <h2>Downloads</h2>
      <span class="downloads-actions">
        <button class="btn-ghost btn-sm" onclick="saveState()">Save State</button>
        <button class="btn-ghost btn-sm" onclick="document.getElementById('importFile').click()">Load State</button>
        <input type="file" id="importFile" accept=".json" class="hidden" onchange="loadState(this)">
      </span>
    </div>
    <div id="taskList"><span class="no-tasks">No downloads yet.</span></div>
  </div>
</div>

<!-- Directory browser modal (hidden by default) -->
<div class="modal-overlay hidden" id="browserModal" onclick="closeBrowser()">
  <div class="modal" onclick="event.stopPropagation()">
    <div class="modal-header">
      <h3>Select Directory</h3>
      <button class="btn-ghost btn-sm" onclick="closeBrowser()">Close</button>
    </div>
    <div class="modal-path" id="browserPath">~</div>
    <div class="modal-body" id="browserBody"></div>
    <div class="modal-new-folder hidden" id="newFolderRow">
      <input type="text" id="newFolderInput" placeholder="Folder name..." onkeydown="if(event.key==='Enter')createFolder();if(event.key==='Escape'){event.stopPropagation();cancelNewFolder();}">
      <button class="btn-primary btn-sm" onclick="createFolder()">Create</button>
      <button class="btn-ghost btn-sm" onclick="cancelNewFolder()">Cancel</button>
    </div>
    <div class="modal-footer">
      <button class="btn-ghost btn-sm" onclick="showNewFolder()">New Folder</button>
      <span style="flex:1"></span>
      <button class="btn-ghost btn-sm" onclick="closeBrowser()">Cancel</button>
      <button class="btn-primary btn-sm" onclick="selectDir()">Select This Folder</button>
    </div>
  </div>
</div>

<script>
  let playlistData = null;
  let selected = new Set();

  const taskSSE = {};
  const taskDetail = {};
  let pollInterval = null;

  // Directory browser state
  let browserCurrentPath = "~";

  function showMessage(text, type) {
    const box = document.getElementById("messageBox");
    box.textContent = text;
    box.className = "message " + type;
    box.classList.remove("hidden");
  }
  function hideMessage() { document.getElementById("messageBox").classList.add("hidden"); }
  function getFormat() { return document.querySelector('input[name="fmt"]:checked').value; }

  function escHtml(s) {
    const d = document.createElement("div");
    d.textContent = s;
    return d.innerHTML;
  }

  // ==================== Fetch Playlist Info ====================
  async function fetchInfo() {
    const url = document.getElementById("urlInput").value.trim();
    if (!url) { showMessage("Please enter a playlist URL.", "error"); return; }

    hideMessage();
    const btn = document.getElementById("fetchBtn");
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span>Fetching...';

    try {
      const res = await fetch("/api/playlist-info", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ url }),
      });
      const data = await res.json();
      if (!res.ok) { showMessage(data.error || "Failed to fetch info", "error"); return; }

      playlistData = data;
      document.getElementById("plTitle").textContent = data.title;
      document.getElementById("plCount").textContent = data.video_count;

      document.getElementById("rangeFrom").max = data.video_count;
      document.getElementById("rangeTo").max = data.video_count;
      document.getElementById("rangeFrom").value = 1;
      document.getElementById("rangeTo").value = data.video_count;

      selected = new Set(data.videos.map((_, i) => i));
      buildSelectList();

      document.getElementById("playlistPanel").classList.remove("hidden");
    } catch (e) {
      showMessage("Network error: " + e.message, "error");
    } finally {
      btn.disabled = false;
      btn.textContent = "Fetch Info";
    }
  }

  // ==================== Selection UI ====================
  function buildSelectList() {
    const list = document.getElementById("selectList");
    list.innerHTML = "";
    playlistData.videos.forEach((v, i) => {
      const item = document.createElement("label");
      item.className = "select-item" + (selected.has(i) ? "" : " deselected");
      item.dataset.idx = i;
      item.innerHTML =
        `<input type="checkbox" ${selected.has(i) ? "checked" : ""} onchange="toggleVideo(${i}, this.checked)">` +
        `<span class="s-idx">${i + 1}</span>` +
        `<span class="s-title">${escHtml(v.title)}</span>`;
      list.appendChild(item);
    });
    updateSelCount();
  }

  function toggleVideo(idx, checked) {
    if (checked) selected.add(idx); else selected.delete(idx);
    const item = document.querySelector(`.select-item[data-idx="${idx}"]`);
    if (item) item.classList.toggle("deselected", !checked);
    updateSelCount();
  }

  function applyRange() {
    const from = parseInt(document.getElementById("rangeFrom").value) || 1;
    const to = parseInt(document.getElementById("rangeTo").value) || playlistData.videos.length;
    const lo = Math.max(0, from - 1);
    const hi = Math.min(playlistData.videos.length, to);

    selected.clear();
    for (let i = lo; i < hi; i++) selected.add(i);
    document.querySelectorAll(".select-item").forEach(item => {
      const idx = parseInt(item.dataset.idx);
      const cb = item.querySelector("input[type=checkbox]");
      const sel = selected.has(idx);
      cb.checked = sel;
      item.classList.toggle("deselected", !sel);
    });
    updateSelCount();
  }

  function selectAll() {
    if (!playlistData) return;
    selected = new Set(playlistData.videos.map((_, i) => i));
    document.getElementById("rangeFrom").value = 1;
    document.getElementById("rangeTo").value = playlistData.videos.length;
    document.querySelectorAll(".select-item").forEach(item => {
      item.querySelector("input[type=checkbox]").checked = true;
      item.classList.remove("deselected");
    });
    updateSelCount();
  }

  function deselectAll() {
    selected.clear();
    document.querySelectorAll(".select-item").forEach(item => {
      item.querySelector("input[type=checkbox]").checked = false;
      item.classList.add("deselected");
    });
    updateSelCount();
  }

  function updateSelCount() {
    const total = playlistData ? playlistData.videos.length : 0;
    document.getElementById("selCount").textContent = `${selected.size} of ${total} selected`;
    document.getElementById("downloadBtn").disabled = selected.size === 0;
  }

  // ==================== Start Download ====================
  async function startDownload() {
    if (!playlistData || selected.size === 0) return;
    const url = document.getElementById("urlInput").value.trim();
    const path = document.getElementById("pathInput").value.trim();
    const fmt = getFormat();
    const indices = Array.from(selected).sort((a, b) => a - b);

    hideMessage();

    // Check for existing tasks with the same URL
    try {
      const tasksRes = await fetch("/api/tasks");
      const existingTasks = await tasksRes.json();
      const duplicate = existingTasks.find(t => t.url === url && ["done", "paused", "cancelled", "error"].includes(t.status));
      if (duplicate) {
        const ok = confirm(
          `This playlist was already downloaded (status: ${duplicate.status}, ${duplicate.completed}/${duplicate.total} completed).\n\n` +
          `Already-downloaded files will be skipped automatically.\nStart a new download task anyway?`
        );
        if (!ok) return;
      }
    } catch (_) {}

    const btn = document.getElementById("downloadBtn");
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span>Starting...';

    try {
      const res = await fetch("/api/download", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          url,
          format: fmt,
          path,
          video_indices: indices,
          playlist_title: playlistData.title,
          videos: playlistData.videos,
        }),
      });
      const data = await res.json();
      if (!res.ok) { showMessage(data.error || "Failed to start download", "error"); return; }

      showMessage(`Download started for "${playlistData.title}" (${indices.length} videos).`, "info");
      connectTaskSSE(data.task_id);
      startPolling();
    } catch (e) {
      showMessage("Network error: " + e.message, "error");
    } finally {
      btn.disabled = false;
      btn.textContent = "Download Selected";
    }
  }

  // ==================== Background Downloads Panel ====================
  function startPolling() {
    if (pollInterval) return;
    pollInterval = setInterval(refreshTaskList, 2000);
    refreshTaskList();
  }

  async function refreshTaskList() {
    try {
      const res = await fetch("/api/tasks");
      const tasks = await res.json();
      renderTaskList(tasks);
      const allDone = tasks.every(t => ["done", "error", "cancelled", "paused"].includes(t.status));
      if (allDone && tasks.length > 0) {
        clearInterval(pollInterval);
        pollInterval = null;
      }
    } catch (_) {}
  }

  function taskCardButtons(t) {
    const isActive = ["downloading", "starting"].includes(t.status);
    const isPaused = t.status === "paused";
    const hasFailed = t.failed > 0;
    const hasIncomplete = t.completed < t.total;

    let html = '';
    if (isActive) {
      html =
        `<button class="btn-warn btn-sm" onclick="event.stopPropagation(); pauseTask('${t.task_id}')">Pause</button>` +
        `<button class="btn-danger btn-sm" onclick="event.stopPropagation(); cancelTask('${t.task_id}')">Cancel</button>`;
    } else if (isPaused) {
      html =
        `<button class="btn-primary btn-sm" onclick="event.stopPropagation(); resumeTask('${t.task_id}')">Resume</button>` +
        `<button class="btn-danger btn-sm" onclick="event.stopPropagation(); cancelTask('${t.task_id}')">Cancel</button>`;
    } else {
      if (hasIncomplete) {
        html += `<button class="btn-primary btn-sm" onclick="event.stopPropagation(); resumeTask('${t.task_id}')">Resume</button>`;
      }
      if (hasFailed) {
        html += `<button class="btn-warn btn-sm" onclick="event.stopPropagation(); retryAllFailed('${t.task_id}')">Retry Failed</button>`;
      }
      html += `<button class="btn-ghost btn-sm" onclick="event.stopPropagation(); deleteTask('${t.task_id}')" title="Remove from list">&#10005;</button>`;
    }
    return html;
  }

  function createTaskCard(t) {
    const pct = t.total > 0 ? Math.round((t.completed / t.total) * 100) : 0;
    const card = document.createElement("div");
    card.className = "task-card";
    card.dataset.taskId = t.task_id;
    card.innerHTML =
      `<div class="task-header" onclick="toggleTaskDetail('${t.task_id}')">` +
        `<span class="task-expand" id="te-${t.task_id}">&#9654;</span>` +
        `<span class="task-title">${escHtml(t.playlist_title)}</span>` +
        `<span class="task-stats" id="ts-${t.task_id}">${t.completed}/${t.total}${t.failed ? ` (${t.failed} failed)` : ''}</span>` +
        `<span class="task-badge ${t.status}" id="tb-${t.task_id}">${t.status}</span>` +
        `<span class="task-btns" id="tbtns-${t.task_id}">${taskCardButtons(t)}</span>` +
      `</div>` +
      `<div class="task-progress-bar"><div class="task-progress-fill" id="tp-${t.task_id}" style="width:${pct}%"></div></div>` +
      `<div class="task-detail" data-task-id="${t.task_id}" id="td-${t.task_id}">` +
        `<div class="video-list" id="tvl-${t.task_id}"></div>` +
      `</div>`;
    return card;
  }

  function updateTaskCard(card, t) {
    const pct = t.total > 0 ? Math.round((t.completed / t.total) * 100) : 0;

    const stats = document.getElementById("ts-" + t.task_id);
    if (stats) stats.textContent = `${t.completed}/${t.total}${t.failed ? ` (${t.failed} failed)` : ''}`;

    const badge = document.getElementById("tb-" + t.task_id);
    if (badge) { badge.className = "task-badge " + t.status; badge.textContent = t.status; }

    const bar = document.getElementById("tp-" + t.task_id);
    if (bar) bar.style.width = pct + "%";

    const btns = document.getElementById("tbtns-" + t.task_id);
    if (btns) btns.innerHTML = taskCardButtons(t);
  }

  function renderTaskList(tasks) {
    const container = document.getElementById("taskList");
    if (tasks.length === 0) {
      container.innerHTML = '<span class="no-tasks">No downloads yet.</span>';
      return;
    }

    // Remove placeholder if present
    const placeholder = container.querySelector(".no-tasks");
    if (placeholder) placeholder.remove();

    // Index existing cards by task_id
    const existingCards = {};
    container.querySelectorAll(".task-card").forEach(card => {
      existingCards[card.dataset.taskId] = card;
    });

    // Remove cards for tasks no longer in the list
    const taskIds = new Set(tasks.map(t => t.task_id));
    for (const [id, card] of Object.entries(existingCards)) {
      if (!taskIds.has(id)) card.remove();
    }

    // Update existing cards in-place, create new ones; appendChild moves existing nodes to maintain order
    tasks.forEach(t => {
      const existing = existingCards[t.task_id];
      if (existing) {
        updateTaskCard(existing, t);
        container.appendChild(existing);
      } else {
        container.appendChild(createTaskCard(t));
      }
    });
  }

  function toggleTaskDetail(taskId) {
    const detail = document.getElementById("td-" + taskId);
    const arrow = document.getElementById("te-" + taskId);
    if (!detail) return;
    const opening = !detail.classList.contains("open");
    detail.classList.toggle("open");
    arrow.classList.toggle("open");

    if (opening) {
      connectTaskSSE(taskId);
    }
  }

  function connectTaskSSE(taskId) {
    if (taskSSE[taskId]) return;
    const es = new EventSource("/api/progress/" + taskId);
    taskSSE[taskId] = es;

    es.onmessage = function(ev) {
      const d = JSON.parse(ev.data);
      taskDetail[taskId] = d;

      const detail = document.getElementById("td-" + taskId);
      if (detail && detail.classList.contains("open")) {
        renderTaskVideos(taskId, d);
      }

      if (["done", "error", "cancelled", "paused"].includes(d.status)) {
        es.close();
        delete taskSSE[taskId];
        refreshTaskList();
      }
    };

    es.onerror = function() {
      es.close();
      delete taskSSE[taskId];
    };
  }

  function renderTaskVideos(taskId, d) {
    const listEl = document.getElementById("tvl-" + taskId);
    if (!listEl || !d.videos || !d.video_indices) return;

    const isActive = ["downloading", "starting"].includes(d.status);
    const expectedCount = d.video_indices.length;

    // Rebuild DOM when count changes
    if (listEl.childElementCount !== expectedCount) {
      listEl.innerHTML = "";
      d.video_indices.forEach(idx => {
        const v = d.videos[idx] || { title: "Unknown" };
        const item = document.createElement("div");
        item.className = "video-item";
        item.id = `tv-${taskId}-${idx}`;
        item.innerHTML =
          `<div class="video-row">` +
            `<span class="video-title">${escHtml(v.title)}</span>` +
            `<span id="tact-${taskId}-${idx}"></span>` +
          `</div>` +
          `<div class="progress-bar-bg"><div class="progress-bar-fill" id="tpb-${taskId}-${idx}"></div></div>` +
          `<div class="status-label" id="tsl-${taskId}-${idx}">Waiting</div>`;
        listEl.appendChild(item);
      });
    }

    // Update progress for each video
    d.video_indices.forEach(idx => {
      const bar = document.getElementById(`tpb-${taskId}-${idx}`);
      const label = document.getElementById(`tsl-${taskId}-${idx}`);
      const actSpan = document.getElementById(`tact-${taskId}-${idx}`);
      if (!bar || !label) return;

      const pct = d.progress[idx];
      if (pct === undefined || pct === null) {
        label.textContent = "Waiting";
        bar.style.width = "0%";
        bar.className = "progress-bar-fill";
        if (actSpan) actSpan.innerHTML = "";
      } else if (pct < 0) {
        bar.className = "progress-bar-fill failed";
        label.textContent = "Failed";
        // Show retry button only when task is not actively downloading
        if (actSpan && !isActive) {
          actSpan.innerHTML =
            `<button class="btn-icon retry" onclick="retryOne('${taskId}', ${idx})" title="Retry">&#8635;</button>`;
        } else if (actSpan) {
          actSpan.innerHTML = "";
        }
      } else if (pct >= 100) {
        bar.style.width = "100%";
        bar.className = "progress-bar-fill";
        label.textContent = "Done";
        if (actSpan) actSpan.innerHTML = "";
      } else {
        bar.style.width = pct + "%";
        bar.className = "progress-bar-fill";
        label.innerHTML = '<span class="spinner"></span>' + pct.toFixed(1) + "%";
        if (actSpan) actSpan.innerHTML = "";
      }
    });
  }

  // ==================== Retry ====================
  async function retryOne(taskId, idx) {
    try {
      const res = await fetch(`/api/retry/${taskId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ video_indices: [idx] }),
      });
      if (res.ok) {
        connectTaskSSE(taskId);
        startPolling();
      }
    } catch (_) {}
  }

  async function retryAllFailed(taskId) {
    try {
      const res = await fetch(`/api/retry/${taskId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({}),
      });
      if (res.ok) {
        connectTaskSSE(taskId);
        startPolling();
      }
    } catch (_) {}
  }

  async function cancelTask(taskId) {
    try {
      await fetch("/api/cancel/" + taskId, { method: "POST" });
    } catch (_) {}
  }

  async function pauseTask(taskId) {
    try {
      await fetch("/api/pause/" + taskId, { method: "POST" });
    } catch (_) {}
  }

  async function resumeTask(taskId) {
    try {
      const res = await fetch("/api/resume/" + taskId, { method: "POST" });
      if (res.ok) {
        connectTaskSSE(taskId);
        startPolling();
      }
    } catch (_) {}
  }

  async function deleteTask(taskId) {
    try {
      await fetch("/api/tasks/" + taskId, { method: "DELETE" });
      if (taskSSE[taskId]) { taskSSE[taskId].close(); delete taskSSE[taskId]; }
      delete taskDetail[taskId];
      refreshTaskList();
    } catch (_) {}
  }

  // ==================== Save / Load State ====================
  function saveState() {
    window.location.href = "/api/export-state";
  }

  async function loadState(fileInput) {
    const file = fileInput.files[0];
    if (!file) return;
    const form = new FormData();
    form.append("file", file);
    try {
      const res = await fetch("/api/import-state", { method: "POST", body: form });
      const data = await res.json();
      if (!res.ok) {
        showMessage(data.error || "Failed to import state", "error");
      } else {
        showMessage(`Imported ${data.imported} task(s).`, "info");
        refreshTaskList();
      }
    } catch (e) {
      showMessage("Network error: " + e.message, "error");
    }
    fileInput.value = "";
  }

  // ==================== Directory Browser ====================
  async function openBrowser() {
    const current = document.getElementById("pathInput").value.trim() || "~";
    browserCurrentPath = current;
    document.getElementById("browserModal").classList.remove("hidden");
    await loadDir(current);
  }

  function closeBrowser() {
    document.getElementById("browserModal").classList.add("hidden");
  }

  function selectDir() {
    document.getElementById("pathInput").value = browserCurrentPath;
    closeBrowser();
  }

  async function loadDir(path) {
    cancelNewFolder();
    const body = document.getElementById("browserBody");
    const pathEl = document.getElementById("browserPath");
    body.innerHTML = '<div class="modal-empty"><span class="spinner"></span> Loading...</div>';
    pathEl.textContent = path;

    try {
      const res = await fetch("/api/browse?path=" + encodeURIComponent(path));
      const data = await res.json();
      if (!res.ok) {
        body.innerHTML = `<div class="modal-empty">${escHtml(data.error || "Error")}</div>`;
        return;
      }

      browserCurrentPath = data.path;
      pathEl.textContent = data.path;
      body.innerHTML = "";

      // Parent directory link
      if (data.parent !== null && data.parent !== undefined) {
        const parentItem = document.createElement("div");
        parentItem.className = "dir-item parent-dir";
        parentItem.onclick = () => loadDir(data.parent);
        parentItem.innerHTML = `<span class="dir-icon">&#128193;</span> ..`;
        body.appendChild(parentItem);
      }

      if (data.dirs.length === 0 && data.parent === null) {
        body.innerHTML = '<div class="modal-empty">No subdirectories</div>';
        return;
      }

      data.dirs.forEach(name => {
        const item = document.createElement("div");
        item.className = "dir-item";
        const childPath = data.path === "~" ? "~/" + name : data.path + "/" + name;
        item.onclick = () => loadDir(childPath);
        item.innerHTML = `<span class="dir-icon">&#128193;</span> ${escHtml(name)}`;
        body.appendChild(item);
      });

      if (data.dirs.length === 0) {
        const empty = document.createElement("div");
        empty.className = "modal-empty";
        empty.textContent = "No subdirectories";
        body.appendChild(empty);
      }
    } catch (e) {
      body.innerHTML = `<div class="modal-empty">Network error</div>`;
    }
  }

  // ==================== New Folder ====================
  function showNewFolder() {
    const row = document.getElementById("newFolderRow");
    row.classList.remove("hidden");
    const input = document.getElementById("newFolderInput");
    input.value = "";
    input.focus();
  }

  function cancelNewFolder() {
    document.getElementById("newFolderRow").classList.add("hidden");
  }

  async function createFolder() {
    const name = document.getElementById("newFolderInput").value.trim();
    if (!name) return;

    try {
      const res = await fetch("/api/mkdir", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ parent: browserCurrentPath, name }),
      });
      const data = await res.json();
      if (!res.ok) {
        alert(data.error || "Failed to create folder");
        return;
      }
      cancelNewFolder();
      // Refresh and navigate into the new folder
      const newPath = browserCurrentPath === "~" ? "~/" + name : browserCurrentPath + "/" + name;
      await loadDir(newPath);
    } catch (e) {
      alert("Network error: " + e.message);
    }
  }

  // ==================== Init ====================
  document.addEventListener("keydown", e => {
    if (e.key === "Escape") closeBrowser();
  });

  document.getElementById("urlInput").addEventListener("keydown", e => {
    if (e.key === "Enter") fetchInfo();
  });

  (async function() {
    try {
      const res = await fetch("/api/tasks");
      const tasks = await res.json();
      if (tasks.length > 0) {
        renderTaskList(tasks);
        const hasActive = tasks.some(t => ["downloading", "starting"].includes(t.status));
        if (hasActive) startPolling();
        tasks.filter(t => ["downloading", "starting"].includes(t.status))
             .forEach(t => connectTaskSSE(t.task_id));
      }
    } catch (_) {}
  })();
</script>
</body>
</html>
